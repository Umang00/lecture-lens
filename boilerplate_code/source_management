// source-management-boilerplate.ts

// 1. API Endpoint Handler (api/sources.js pattern)
const { createClient } = require('@supabase/supabase-js');

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const supabaseAdmin = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// Enhanced error logging helper
function logApiError(endpoint, error, context = {}) {
  console.error(`API Error [${endpoint}]:`, {
    error: error.message,
    stack: error.stack,
    context,
    timestamp: new Date().toISOString()
  });
}

// Authentication helper
async function authenticateUser(req) {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return { error: 'Missing or invalid authorization header' };
    }

    const token = authHeader.substring(7);
    const supabase = createClient(SUPABASE_URL, process.env.SUPABASE_ANON_KEY);
    const { data: { user }, error } = await supabase.auth.getUser(token);

    if (error || !user) {
      return { error: 'Invalid token' };
    }

    return { user };
  } catch (error) {
    logApiError('authenticateUser', error, { endpoint: req.url });
    return { error: 'Authentication failed' };
  }
}

// Main handler
module.exports = async function handler(req, res) {
  try {
    if (req.method === 'GET') {
      return handleGetSources(req, res);
    } else if (req.method === 'POST') {
      return handleAddSource(req, res);
    } else if (req.method === 'PUT') {
      return handleUpdateSource(req, res);
    } else if (req.method === 'DELETE') {
      return handleDeleteSource(req, res);
    } else {
      return res.status(405).json({
        error: 'Method not allowed',
        timestamp: new Date().toISOString()
      });
    }
  } catch (error) {
    logApiError('sources-handler', error, {
      method: req.method,
      url: req.url
    });

    return res.status(500).json({
      error: 'Internal server error',
      message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong',
      timestamp: new Date().toISOString()
    });
  }
};

// 2. Get Sources Handler
async function handleGetSources(req, res) {
  try {
    const authResult = await authenticateUser(req);
    if ('error' in authResult) {
      return res.status(401).json({
        error: authResult.error,
        timestamp: new Date().toISOString()
      });
    }

    const { user } = authResult;

    const { data, error } = await supabaseAdmin
      .from('sources')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });

    if (error) {
      logApiError('handleGetSources', error, { userId: user.id });
      return res.status(500).json({
        error: 'Failed to fetch sources',
        timestamp: new Date().toISOString()
      });
    }

    return res.status(200).json({
      success: true,
      data: data || [],
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logApiError('handleGetSources', error, { method: 'GET' });
    return res.status(500).json({
      error: 'Internal server error',
      message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong',
      timestamp: new Date().toISOString()
    });
  }
}

// 3. Add Source Handler
async function handleAddSource(req, res) {
  try {
    const authResult = await authenticateUser(req);
    if ('error' in authResult) {
      return res.status(401).json({
        error: authResult.error,
        timestamp: new Date().toISOString()
      });
    }

    const { user } = authResult;
    const { kind, url, name, isActive } = req.body;

    if (!kind || !url) {
      return res.status(400).json({
        error: 'Kind and URL are required',
        timestamp: new Date().toISOString()
      });
    }

    // Validate source input
    const validationError = validateSourceInput(kind, url);
    if (validationError) {
      return res.status(400).json({
        error: validationError,
        timestamp: new Date().toISOString()
      });
    }

    const { data, error } = await supabaseAdmin
      .from('sources')
      .insert({
        user_id: user.id,
        kind: kind,
        url: url,
        name: name || url,
        is_active: isActive !== false
      })
      .select()
      .single();

    if (error) {
      logApiError('handleAddSource', error, { userId: user.id, kind, url });
      return res.status(500).json({
        error: 'Failed to save source',
        timestamp: new Date().toISOString()
      });
    }

    return res.status(200).json({
      success: true,
      data: data,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logApiError('handleAddSource', error, { method: 'POST' });
    return res.status(500).json({
      error: 'Internal server error',
      message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong',
      timestamp: new Date().toISOString()
    });
  }
}

// 4. Update Source Handler
async function handleUpdateSource(req, res) {
  try {
    const authResult = await authenticateUser(req);
    if ('error' in authResult) {
      return res.status(401).json({
        error: authResult.error,
        timestamp: new Date().toISOString()
      });
    }

    const { user } = authResult;
    const { id } = req.query;
    const { isActive, name, url } = req.body;

    if (!id) {
      return res.status(400).json({
        error: 'Source ID is required',
        timestamp: new Date().toISOString()
      });
    }

    const updateData = {};
    if (typeof isActive === 'boolean') updateData.is_active = isActive;
    if (name) updateData.name = name;
    if (url) updateData.url = url;

    const { data, error } = await supabaseAdmin
      .from('sources')
      .update(updateData)
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single();

    if (error) {
      logApiError('handleUpdateSource', error, { userId: user.id, sourceId: id });
      return res.status(500).json({
        error: 'Failed to update source',
        timestamp: new Date().toISOString()
      });
    }

    return res.status(200).json({
      success: true,
      data: data,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logApiError('handleUpdateSource', error, { method: 'PUT' });
    return res.status(500).json({
      error: 'Internal server error',
      message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong',
      timestamp: new Date().toISOString()
    });
  }
}

// 5. Delete Source Handler
async function handleDeleteSource(req, res) {
  try {
    const authResult = await authenticateUser(req);
    if ('error' in authResult) {
      return res.status(401).json({
        error: authResult.error,
        timestamp: new Date().toISOString()
      });
    }

    const { user } = authResult;
    const { id } = req.query;

    if (!id) {
      return res.status(400).json({
        error: 'Source ID is required',
        timestamp: new Date().toISOString()
      });
    }

    const { error } = await supabaseAdmin
      .from('sources')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id);

    if (error) {
      logApiError('handleDeleteSource', error, { userId: user.id, sourceId: id });
      return res.status(500).json({
        error: 'Failed to delete source',
        timestamp: new Date().toISOString()
      });
    }

    return res.status(200).json({
      success: true,
      message: 'Source deleted successfully',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logApiError('handleDeleteSource', error, { method: 'DELETE' });
    return res.status(500).json({
      error: 'Internal server error',
      message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong',
      timestamp: new Date().toISOString()
    });
  }
}

// 6. Validation Function
function validateSourceInput(kind, url) {
  if (!kind || !url.trim()) {
    return 'Please select a source type and enter a URL/handle';
  }

  const trimmedUrl = url.trim();

  switch (kind) {
    case 'rss':
      if (!trimmedUrl.startsWith('http://') && !trimmedUrl.startsWith('https://')) {
        return 'RSS feed URL must start with http:// or https://';
      }
      if (!trimmedUrl.includes('.xml') && !trimmedUrl.includes('/rss') && !trimmedUrl.includes('/feed')) {
        return 'RSS feed URL should contain .xml, /rss, or /feed';
      }
      break;

    case 'reddit':
      if (!trimmedUrl.startsWith('r/')) {
        return 'Reddit subreddit should start with r/ (e.g., r/OpenAI)';
      }
      if (trimmedUrl.includes(' ')) {
        return 'Reddit subreddit should not contain spaces';
      }
      break;

    case 'youtube':
      if (!trimmedUrl.includes('youtube.com') && !trimmedUrl.includes('youtu.be')) {
        return 'YouTube URL must be a valid YouTube channel or video URL';
      }
      break;

    case 'github':
      if (!trimmedUrl.includes('github.com')) {
        return 'GitHub URL must be a valid GitHub repository URL';
      }
      if (!trimmedUrl.includes('/')) {
        return 'GitHub URL should include repository path (e.g., username/repo)';
      }
      break;

    case 'blog':
      if (!trimmedUrl.startsWith('http://') && !trimmedUrl.startsWith('https://')) {
        return 'Blog URL must start with http:// or https://';
      }
      break;

    case 'x':
      if (!trimmedUrl.startsWith('@') && !trimmedUrl.includes('twitter.com') && !trimmedUrl.includes('x.com')) {
        return 'X/Twitter handle should start with @ or be a valid Twitter URL';
      }
      break;

    default:
      return 'Unsupported source type';
  }

  return null; // No validation errors
}